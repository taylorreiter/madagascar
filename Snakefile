import pandas as pd

t = pd.read_csv("inputs/madagascar_metadata_sub.csv")
SRA = t["run_accession"]
SAMPLE = t["library_name"] 

SGB = pd.read_csv("inputs/sgbs_sub.txt", sep = "\t", header = None)
SGB = SGB[0] 

ENV = 'env.yml'
ENV_KOFAMSCAN = 'env_kofamscan.yml'

rule all:
    input:
        expand("outputs/mapping/all_sgbs/{SRA_ID}-v-all_sgbs.flagstat.txt", SRA_ID=SRA),
        'outputs/sgbs/sourmash_compare/sgb_comp.matrix.png' 
        #expand("outputs/abundtrim/{SRA_ID}.abundtrim.fq.gz", SRA_ID=SRA)

# Download and trim raw reads
rule fastq_dump_abundtrim:
    output: "outputs/abundtrim/{SRA_ID}.abundtrim.fq.gz"
    params: SRA_ID="{SRA_ID}"
    conda: ENV
    shell: """
    # set +o pipefail - explicitly tell snakemake to ignore the pipefail. 
    set +o pipefail
    fastq-dump -A {params.SRA_ID} -Z | head -n 4000000 |  trim-low-abund.py -C 3 -Z 18 -M 8e9 -V -k 31 - -o {output} --gzip 
    """

# Download SGBs (MAGs; bins) generated by Pasolli et al. 2019. Align reads to bins to
# get percent of reads captured by high- and medium-quality bins. These bins are
# reproducible across methods and have high completeness and low contamination. 

rule download_sgbs:
    output:"inputs/madacascar_SGBs.tar.gz"
    shell:'''
    curl -L -o {output} https://osf.io/mgj62/download
    '''

rule decompress_sgbs:
    output: expand("inputs/sgbs/CM_madagascar__{sgb}.fa.gz", sgb = SGB)
    input: "inputs/madagascar_SGBs.tar.gz"
    params: out_dir = "inputs/sgbs"
    shell:'''
    tar xvf {input} -C {params.out_dir}
    '''

rule gunzip_sgbs:
    output: "inputs/sgbs/CM_madagascar__{sgb}.fa"
    input: "inputs/sgbs/CM_madagascar__{sgb}.fa.gz"
    shell:'''
    gunzip {input}
    '''

# CHARACTERIZE SGBs

# check mapping rate just to SGBs. If ~high (close to NCBI+SGB mappability from 
# Pasolli et al.), continue with simple pipeline of only using bins as queries.
# if ~low (less than ~5%?), run gather with RefSeq (?), Pasolli, Nayfach, and 
# Almeida

# Concatenate all references together to make one reference multifasta to map against
# simulataneously
rule cat_sgbs:
    input: expand("inputs/sgbs/CM_madagascar__{sgb}.fa", sgb = SGB)
    output: "inputs/sgbs/all_sgbs/all_sgbs.fa"
    shell: '''
    cat {input} > {output}
    '''
    
rule rule_index_sgbs:
    input: "inputs/sgbs/all_sgbs/all_sgbs.fa"
    output: "inputs/sgbs/all_sgbs/all_sgbs.fa.pac"
    conda: ENV
    shell:'''
    bwa index {input}
    '''
    
rule rule_align_reads_to_sgbs:
    input:
        ref = "inputs/sgbs/all_sgbs/all_sgbs.fa",
        index = "inputs/sgbs/all_sgbs/all_sgbs.fa.pac",
        reads = "outputs/abundtrim/{SRA_ID}.abundtrim.fq.gz"
    output: "outputs/mapping/all_sgbs/{SRA_ID}-v-all_sgbs.sam"
    conda: ENV
    shell:'''
    bwa mem -t 4 {input.ref} {input.reads}  > {output}
    '''

rule sam_to_bam_sgb_alignment:
    input: "outputs/mapping/all_sgbs/{SRA_ID}-v-all_sgbs.sam"
    output: "outputs/mapping/all_sgbs/{SRA_ID}-v-all_sgbs.bam"
    conda: ENV
    shell:'''
    samtools view -S -b {input} > {output}
    '''

rule sort_bam_sgb_alignment:
    input: "outputs/mapping/all_sgbs/{SRA_ID}-v-all_sgbs.bam"
    output: "outputs/mapping/all_sgbs/{SRA_ID}-v-all_sgbs.sorted.bam"
    conda: ENV
    shell:'''
    samtools sort {input} -o {output}
    '''

rule flagstat_sgb_alignment:
    input: "outputs/mapping/all_sgbs/{SRA_ID}-v-all_sgbs.sorted.bam"
    output: "outputs/mapping/all_sgbs/{SRA_ID}-v-all_sgbs.flagstat.txt"
    conda: ENV
    shell:'''
    samtools flagstat {input} > {output}
    '''

# annotate SGBs. Use prokka to find ORFs, and kofamscan to generate KEGG orthologs. 
# Consider other tools that will help with measuring pathway completeness.


#rule kofamscan_sgbs:
#    conda: ENV_KOFAMSCAN

rule prokka_sgbs:
    output: 'outputs/sgbs/prokka/{sgb}.faa'
    input:  'inputs/sgbs/CM_madagascar__{sgb}.fa'
    conda: 'env_sgb.yml'
    params: outdir = 'outputs/sgbs/prokka'
    shell:"""
    prokka {input} \
        --outdir {params.outdir} \
        --prefix {wildcards.sgb} \
        --metagenome --force \
        --locustag {wildcards.sgb}

    touch {output}
    """

# Get relatedness of sgbs:

rule sourmash_compute_sgbs:
    output: 'outputs/sgbs/sigs/CM_madagascar__{sgb}.sig'
    input: 'inputs/sgbs/CM_madagascar__{sgb}.fa'
    conda: ENV
    shell:'''
    sourmash compute -k 21,31,51 --scaled 2000 --track-abundance -o {output} {input}
    '''

rule sourmash_compare_sgbs_numpy:
    output: 'outputs/sgbs/sourmash_compare/sgb_comp'
    input: expand('outputs/sgbs/sigs/CM_madagascar__{sgb}.sig', sgb = SGB)
    conda: ENV
    shell:'''
    sourmash compare -k 31 -o {output} {input}
    '''

rule sourmash_compare_sgbs_csv:
    output: 'outputs/sgbs/sourmash_compare/sgb_comp.csv'
    input: expand('outputs/sgbs/sigs/CM_madagascar__{sgb}.sig', sgb = SGB)
    conda: ENV
    shell:'''
    sourmash compare -k 31 --csv {output} {input}
    '''
    
rule sourmash_plot_sgbs:
    output: 'outputs/sgbs/sourmash_compare/sgb_comp.matrix.png'
    input: 'outputs/sgbs/sourmash_compare/sgb_comp'
    conda: ENV
    shell:'''
    sourmash plot --labels {input}
    mv sgb*png outputs/sgbs/sourmash_compare/
    '''
    
#rule gtotree_sgbs:

# SPACEGRAPHCATS meowwww
# Perform queries to increase bin completeness. 

#rule query_with_sgbs:

# SPAdes
# spades is built for genomes, so should work well here. If nucleotides can be assembled,
# spades will assemble it! More conservative than PLASS.

#rule assemble_nbhds_spades:

#rule rule_align_reads_to_nbhds_spades:

#rule sam_to_bam_nbhds_spades_alignment:

#rule sort_bam_nbhds_spades_alignment:

#rule flagstat_nbhds_spades_alignment:

#rule prokka_nbhds_spades:

#rule kofamscan_nbhds_spads:

# PLASS
# PLASS is quite promiscuous and will assemble anything that reasonably can be assembled.
# This is useful to get things that are always missed by nt assemblers, but it only
# catches protein sequences, not regulatory seqs. However, if SPAdes is not successful,
# it's a good option!

#rule assemble_nbhds_plass:

#rule rm_stops_plass:

#rule cdhit100_plass:

#rule clean_plass:

#rule cut_plass:

#rule dedup_plass:

#rule rule_align_reads_to_nbhds_plass:

#rule sam_to_bam_nbhds_plass_alignment:

#rule sort_bam_nbhds_plass_alignment:

#rule flagstat_nbhds_plass_alignment:

#rule prokka_nbhds_plass:

#rule kofamscan_nbhds_plass:

# SOFTWARE AND DATABASE DOWNLOADS. 
# these packages are not available through conda.

#rule download_kofamscan:
#    output:
#    shell:'''
#    
#    ''' 
